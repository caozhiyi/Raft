// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: brpc/policy/public_pbrpc_meta.proto

#ifndef PROTOBUF_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto__INCLUDED
#define PROTOBUF_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace brpc {
namespace policy {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
void protobuf_AssignDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
void protobuf_ShutdownFile_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();

class PublicPbrpcRequest;
class RequestHead;
class RequestBody;
class PublicPbrpcResponse;
class ResponseHead;
class ResponseBody;

// ===================================================================

class PublicPbrpcRequest : public ::google::protobuf::Message {
 public:
  PublicPbrpcRequest();
  virtual ~PublicPbrpcRequest();

  PublicPbrpcRequest(const PublicPbrpcRequest& from);

  inline PublicPbrpcRequest& operator=(const PublicPbrpcRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicPbrpcRequest& default_instance();

  void Swap(PublicPbrpcRequest* other);

  // implements Message ----------------------------------------------

  PublicPbrpcRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PublicPbrpcRequest& from);
  void MergeFrom(const PublicPbrpcRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .brpc.policy.RequestHead requestHead = 1;
  inline bool has_requesthead() const;
  inline void clear_requesthead();
  static const int kRequestHeadFieldNumber = 1;
  inline const ::brpc::policy::RequestHead& requesthead() const;
  inline ::brpc::policy::RequestHead* mutable_requesthead();
  inline ::brpc::policy::RequestHead* release_requesthead();
  inline void set_allocated_requesthead(::brpc::policy::RequestHead* requesthead);

  // repeated .brpc.policy.RequestBody requestBody = 2;
  inline int requestbody_size() const;
  inline void clear_requestbody();
  static const int kRequestBodyFieldNumber = 2;
  inline const ::brpc::policy::RequestBody& requestbody(int index) const;
  inline ::brpc::policy::RequestBody* mutable_requestbody(int index);
  inline ::brpc::policy::RequestBody* add_requestbody();
  inline const ::google::protobuf::RepeatedPtrField< ::brpc::policy::RequestBody >&
      requestbody() const;
  inline ::google::protobuf::RepeatedPtrField< ::brpc::policy::RequestBody >*
      mutable_requestbody();

  // @@protoc_insertion_point(class_scope:brpc.policy.PublicPbrpcRequest)
 private:
  inline void set_has_requesthead();
  inline void clear_has_requesthead();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::brpc::policy::RequestHead* requesthead_;
  ::google::protobuf::RepeatedPtrField< ::brpc::policy::RequestBody > requestbody_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
  friend void protobuf_AssignDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
  friend void protobuf_ShutdownFile_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();

  void InitAsDefaultInstance();
  static PublicPbrpcRequest* default_instance_;
};
// -------------------------------------------------------------------

class RequestHead : public ::google::protobuf::Message {
 public:
  RequestHead();
  virtual ~RequestHead();

  RequestHead(const RequestHead& from);

  inline RequestHead& operator=(const RequestHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHead& default_instance();

  void Swap(RequestHead* other);

  // implements Message ----------------------------------------------

  RequestHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestHead& from);
  void MergeFrom(const RequestHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string from_host = 1;
  inline bool has_from_host() const;
  inline void clear_from_host();
  static const int kFromHostFieldNumber = 1;
  inline const ::std::string& from_host() const;
  inline void set_from_host(const ::std::string& value);
  inline void set_from_host(const char* value);
  inline void set_from_host(const char* value, size_t size);
  inline ::std::string* mutable_from_host();
  inline ::std::string* release_from_host();
  inline void set_allocated_from_host(::std::string* from_host);

  // optional uint32 content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 content_type() const;
  inline void set_content_type(::google::protobuf::uint32 value);

  // optional bool connection = 3;
  inline bool has_connection() const;
  inline void clear_connection();
  static const int kConnectionFieldNumber = 3;
  inline bool connection() const;
  inline void set_connection(bool value);

  // optional string charset = 4;
  inline bool has_charset() const;
  inline void clear_charset();
  static const int kCharsetFieldNumber = 4;
  inline const ::std::string& charset() const;
  inline void set_charset(const ::std::string& value);
  inline void set_charset(const char* value);
  inline void set_charset(const char* value, size_t size);
  inline ::std::string* mutable_charset();
  inline ::std::string* release_charset();
  inline void set_allocated_charset(::std::string* charset);

  // optional string accept_charset = 5;
  inline bool has_accept_charset() const;
  inline void clear_accept_charset();
  static const int kAcceptCharsetFieldNumber = 5;
  inline const ::std::string& accept_charset() const;
  inline void set_accept_charset(const ::std::string& value);
  inline void set_accept_charset(const char* value);
  inline void set_accept_charset(const char* value, size_t size);
  inline ::std::string* mutable_accept_charset();
  inline ::std::string* release_accept_charset();
  inline void set_allocated_accept_charset(::std::string* accept_charset);

  // optional string create_time = 6;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 6;
  inline const ::std::string& create_time() const;
  inline void set_create_time(const ::std::string& value);
  inline void set_create_time(const char* value);
  inline void set_create_time(const char* value, size_t size);
  inline ::std::string* mutable_create_time();
  inline ::std::string* release_create_time();
  inline void set_allocated_create_time(::std::string* create_time);

  // optional uint64 log_id = 7;
  inline bool has_log_id() const;
  inline void clear_log_id();
  static const int kLogIdFieldNumber = 7;
  inline ::google::protobuf::uint64 log_id() const;
  inline void set_log_id(::google::protobuf::uint64 value);

  // optional uint32 compress_type = 8;
  inline bool has_compress_type() const;
  inline void clear_compress_type();
  static const int kCompressTypeFieldNumber = 8;
  inline ::google::protobuf::uint32 compress_type() const;
  inline void set_compress_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:brpc.policy.RequestHead)
 private:
  inline void set_has_from_host();
  inline void clear_has_from_host();
  inline void set_has_content_type();
  inline void clear_has_content_type();
  inline void set_has_connection();
  inline void clear_has_connection();
  inline void set_has_charset();
  inline void clear_has_charset();
  inline void set_has_accept_charset();
  inline void clear_has_accept_charset();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_log_id();
  inline void clear_has_log_id();
  inline void set_has_compress_type();
  inline void clear_has_compress_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_host_;
  ::google::protobuf::uint32 content_type_;
  bool connection_;
  ::std::string* charset_;
  ::std::string* accept_charset_;
  ::std::string* create_time_;
  ::google::protobuf::uint64 log_id_;
  ::google::protobuf::uint32 compress_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
  friend void protobuf_AssignDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
  friend void protobuf_ShutdownFile_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();

  void InitAsDefaultInstance();
  static RequestHead* default_instance_;
};
// -------------------------------------------------------------------

class RequestBody : public ::google::protobuf::Message {
 public:
  RequestBody();
  virtual ~RequestBody();

  RequestBody(const RequestBody& from);

  inline RequestBody& operator=(const RequestBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestBody& default_instance();

  void Swap(RequestBody* other);

  // implements Message ----------------------------------------------

  RequestBody* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestBody& from);
  void MergeFrom(const RequestBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string charset = 2;
  inline bool has_charset() const;
  inline void clear_charset();
  static const int kCharsetFieldNumber = 2;
  inline const ::std::string& charset() const;
  inline void set_charset(const ::std::string& value);
  inline void set_charset(const char* value);
  inline void set_charset(const char* value, size_t size);
  inline ::std::string* mutable_charset();
  inline ::std::string* release_charset();
  inline void set_allocated_charset(::std::string* charset);

  // required string service = 3;
  inline bool has_service() const;
  inline void clear_service();
  static const int kServiceFieldNumber = 3;
  inline const ::std::string& service() const;
  inline void set_service(const ::std::string& value);
  inline void set_service(const char* value);
  inline void set_service(const char* value, size_t size);
  inline ::std::string* mutable_service();
  inline ::std::string* release_service();
  inline void set_allocated_service(::std::string* service);

  // required uint32 method_id = 4;
  inline bool has_method_id() const;
  inline void clear_method_id();
  static const int kMethodIdFieldNumber = 4;
  inline ::google::protobuf::uint32 method_id() const;
  inline void set_method_id(::google::protobuf::uint32 value);

  // required uint64 id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional bytes serialized_request = 6;
  inline bool has_serialized_request() const;
  inline void clear_serialized_request();
  static const int kSerializedRequestFieldNumber = 6;
  inline const ::std::string& serialized_request() const;
  inline void set_serialized_request(const ::std::string& value);
  inline void set_serialized_request(const char* value);
  inline void set_serialized_request(const void* value, size_t size);
  inline ::std::string* mutable_serialized_request();
  inline ::std::string* release_serialized_request();
  inline void set_allocated_serialized_request(::std::string* serialized_request);

  // @@protoc_insertion_point(class_scope:brpc.policy.RequestBody)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_charset();
  inline void clear_has_charset();
  inline void set_has_service();
  inline void clear_has_service();
  inline void set_has_method_id();
  inline void clear_has_method_id();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_serialized_request();
  inline void clear_has_serialized_request();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;
  ::std::string* charset_;
  ::std::string* service_;
  ::google::protobuf::uint64 id_;
  ::std::string* serialized_request_;
  ::google::protobuf::uint32 method_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
  friend void protobuf_AssignDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
  friend void protobuf_ShutdownFile_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();

  void InitAsDefaultInstance();
  static RequestBody* default_instance_;
};
// -------------------------------------------------------------------

class PublicPbrpcResponse : public ::google::protobuf::Message {
 public:
  PublicPbrpcResponse();
  virtual ~PublicPbrpcResponse();

  PublicPbrpcResponse(const PublicPbrpcResponse& from);

  inline PublicPbrpcResponse& operator=(const PublicPbrpcResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicPbrpcResponse& default_instance();

  void Swap(PublicPbrpcResponse* other);

  // implements Message ----------------------------------------------

  PublicPbrpcResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PublicPbrpcResponse& from);
  void MergeFrom(const PublicPbrpcResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .brpc.policy.ResponseHead responseHead = 1;
  inline bool has_responsehead() const;
  inline void clear_responsehead();
  static const int kResponseHeadFieldNumber = 1;
  inline const ::brpc::policy::ResponseHead& responsehead() const;
  inline ::brpc::policy::ResponseHead* mutable_responsehead();
  inline ::brpc::policy::ResponseHead* release_responsehead();
  inline void set_allocated_responsehead(::brpc::policy::ResponseHead* responsehead);

  // repeated .brpc.policy.ResponseBody responseBody = 2;
  inline int responsebody_size() const;
  inline void clear_responsebody();
  static const int kResponseBodyFieldNumber = 2;
  inline const ::brpc::policy::ResponseBody& responsebody(int index) const;
  inline ::brpc::policy::ResponseBody* mutable_responsebody(int index);
  inline ::brpc::policy::ResponseBody* add_responsebody();
  inline const ::google::protobuf::RepeatedPtrField< ::brpc::policy::ResponseBody >&
      responsebody() const;
  inline ::google::protobuf::RepeatedPtrField< ::brpc::policy::ResponseBody >*
      mutable_responsebody();

  // @@protoc_insertion_point(class_scope:brpc.policy.PublicPbrpcResponse)
 private:
  inline void set_has_responsehead();
  inline void clear_has_responsehead();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::brpc::policy::ResponseHead* responsehead_;
  ::google::protobuf::RepeatedPtrField< ::brpc::policy::ResponseBody > responsebody_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
  friend void protobuf_AssignDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
  friend void protobuf_ShutdownFile_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();

  void InitAsDefaultInstance();
  static PublicPbrpcResponse* default_instance_;
};
// -------------------------------------------------------------------

class ResponseHead : public ::google::protobuf::Message {
 public:
  ResponseHead();
  virtual ~ResponseHead();

  ResponseHead(const ResponseHead& from);

  inline ResponseHead& operator=(const ResponseHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHead& default_instance();

  void Swap(ResponseHead* other);

  // implements Message ----------------------------------------------

  ResponseHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseHead& from);
  void MergeFrom(const ResponseHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string from_host = 3;
  inline bool has_from_host() const;
  inline void clear_from_host();
  static const int kFromHostFieldNumber = 3;
  inline const ::std::string& from_host() const;
  inline void set_from_host(const ::std::string& value);
  inline void set_from_host(const char* value);
  inline void set_from_host(const char* value, size_t size);
  inline ::std::string* mutable_from_host();
  inline ::std::string* release_from_host();
  inline void set_allocated_from_host(::std::string* from_host);

  // optional uint32 compress_type = 4;
  inline bool has_compress_type() const;
  inline void clear_compress_type();
  static const int kCompressTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 compress_type() const;
  inline void set_compress_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:brpc.policy.ResponseHead)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_from_host();
  inline void clear_has_from_host();
  inline void set_has_compress_type();
  inline void clear_has_compress_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::uint32 compress_type_;
  ::std::string* from_host_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
  friend void protobuf_AssignDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
  friend void protobuf_ShutdownFile_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();

  void InitAsDefaultInstance();
  static ResponseHead* default_instance_;
};
// -------------------------------------------------------------------

class ResponseBody : public ::google::protobuf::Message {
 public:
  ResponseBody();
  virtual ~ResponseBody();

  ResponseBody(const ResponseBody& from);

  inline ResponseBody& operator=(const ResponseBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseBody& default_instance();

  void Swap(ResponseBody* other);

  // implements Message ----------------------------------------------

  ResponseBody* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseBody& from);
  void MergeFrom(const ResponseBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes serialized_response = 1;
  inline bool has_serialized_response() const;
  inline void clear_serialized_response();
  static const int kSerializedResponseFieldNumber = 1;
  inline const ::std::string& serialized_response() const;
  inline void set_serialized_response(const ::std::string& value);
  inline void set_serialized_response(const char* value);
  inline void set_serialized_response(const void* value, size_t size);
  inline ::std::string* mutable_serialized_response();
  inline ::std::string* release_serialized_response();
  inline void set_allocated_serialized_response(::std::string* serialized_response);

  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional int32 error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline ::google::protobuf::int32 error() const;
  inline void set_error(::google::protobuf::int32 value);

  // required uint64 id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:brpc.policy.ResponseBody)
 private:
  inline void set_has_serialized_response();
  inline void clear_has_serialized_response();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* serialized_response_;
  ::std::string* version_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::int32 error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
  friend void protobuf_AssignDesc_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();
  friend void protobuf_ShutdownFile_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto();

  void InitAsDefaultInstance();
  static ResponseBody* default_instance_;
};
// ===================================================================


// ===================================================================

// PublicPbrpcRequest

// optional .brpc.policy.RequestHead requestHead = 1;
inline bool PublicPbrpcRequest::has_requesthead() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicPbrpcRequest::set_has_requesthead() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PublicPbrpcRequest::clear_has_requesthead() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PublicPbrpcRequest::clear_requesthead() {
  if (requesthead_ != NULL) requesthead_->::brpc::policy::RequestHead::Clear();
  clear_has_requesthead();
}
inline const ::brpc::policy::RequestHead& PublicPbrpcRequest::requesthead() const {
  return requesthead_ != NULL ? *requesthead_ : *default_instance_->requesthead_;
}
inline ::brpc::policy::RequestHead* PublicPbrpcRequest::mutable_requesthead() {
  set_has_requesthead();
  if (requesthead_ == NULL) requesthead_ = new ::brpc::policy::RequestHead;
  return requesthead_;
}
inline ::brpc::policy::RequestHead* PublicPbrpcRequest::release_requesthead() {
  clear_has_requesthead();
  ::brpc::policy::RequestHead* temp = requesthead_;
  requesthead_ = NULL;
  return temp;
}
inline void PublicPbrpcRequest::set_allocated_requesthead(::brpc::policy::RequestHead* requesthead) {
  delete requesthead_;
  requesthead_ = requesthead;
  if (requesthead) {
    set_has_requesthead();
  } else {
    clear_has_requesthead();
  }
}

// repeated .brpc.policy.RequestBody requestBody = 2;
inline int PublicPbrpcRequest::requestbody_size() const {
  return requestbody_.size();
}
inline void PublicPbrpcRequest::clear_requestbody() {
  requestbody_.Clear();
}
inline const ::brpc::policy::RequestBody& PublicPbrpcRequest::requestbody(int index) const {
  return requestbody_.Get(index);
}
inline ::brpc::policy::RequestBody* PublicPbrpcRequest::mutable_requestbody(int index) {
  return requestbody_.Mutable(index);
}
inline ::brpc::policy::RequestBody* PublicPbrpcRequest::add_requestbody() {
  return requestbody_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::brpc::policy::RequestBody >&
PublicPbrpcRequest::requestbody() const {
  return requestbody_;
}
inline ::google::protobuf::RepeatedPtrField< ::brpc::policy::RequestBody >*
PublicPbrpcRequest::mutable_requestbody() {
  return &requestbody_;
}

// -------------------------------------------------------------------

// RequestHead

// optional string from_host = 1;
inline bool RequestHead::has_from_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestHead::set_has_from_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestHead::clear_has_from_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestHead::clear_from_host() {
  if (from_host_ != &::google::protobuf::internal::kEmptyString) {
    from_host_->clear();
  }
  clear_has_from_host();
}
inline const ::std::string& RequestHead::from_host() const {
  return *from_host_;
}
inline void RequestHead::set_from_host(const ::std::string& value) {
  set_has_from_host();
  if (from_host_ == &::google::protobuf::internal::kEmptyString) {
    from_host_ = new ::std::string;
  }
  from_host_->assign(value);
}
inline void RequestHead::set_from_host(const char* value) {
  set_has_from_host();
  if (from_host_ == &::google::protobuf::internal::kEmptyString) {
    from_host_ = new ::std::string;
  }
  from_host_->assign(value);
}
inline void RequestHead::set_from_host(const char* value, size_t size) {
  set_has_from_host();
  if (from_host_ == &::google::protobuf::internal::kEmptyString) {
    from_host_ = new ::std::string;
  }
  from_host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestHead::mutable_from_host() {
  set_has_from_host();
  if (from_host_ == &::google::protobuf::internal::kEmptyString) {
    from_host_ = new ::std::string;
  }
  return from_host_;
}
inline ::std::string* RequestHead::release_from_host() {
  clear_has_from_host();
  if (from_host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_host_;
    from_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestHead::set_allocated_from_host(::std::string* from_host) {
  if (from_host_ != &::google::protobuf::internal::kEmptyString) {
    delete from_host_;
  }
  if (from_host) {
    set_has_from_host();
    from_host_ = from_host;
  } else {
    clear_has_from_host();
    from_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 content_type = 2;
inline bool RequestHead::has_content_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestHead::set_has_content_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestHead::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestHead::clear_content_type() {
  content_type_ = 0u;
  clear_has_content_type();
}
inline ::google::protobuf::uint32 RequestHead::content_type() const {
  return content_type_;
}
inline void RequestHead::set_content_type(::google::protobuf::uint32 value) {
  set_has_content_type();
  content_type_ = value;
}

// optional bool connection = 3;
inline bool RequestHead::has_connection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestHead::set_has_connection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestHead::clear_has_connection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestHead::clear_connection() {
  connection_ = false;
  clear_has_connection();
}
inline bool RequestHead::connection() const {
  return connection_;
}
inline void RequestHead::set_connection(bool value) {
  set_has_connection();
  connection_ = value;
}

// optional string charset = 4;
inline bool RequestHead::has_charset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestHead::set_has_charset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestHead::clear_has_charset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestHead::clear_charset() {
  if (charset_ != &::google::protobuf::internal::kEmptyString) {
    charset_->clear();
  }
  clear_has_charset();
}
inline const ::std::string& RequestHead::charset() const {
  return *charset_;
}
inline void RequestHead::set_charset(const ::std::string& value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void RequestHead::set_charset(const char* value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void RequestHead::set_charset(const char* value, size_t size) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestHead::mutable_charset() {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  return charset_;
}
inline ::std::string* RequestHead::release_charset() {
  clear_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charset_;
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestHead::set_allocated_charset(::std::string* charset) {
  if (charset_ != &::google::protobuf::internal::kEmptyString) {
    delete charset_;
  }
  if (charset) {
    set_has_charset();
    charset_ = charset;
  } else {
    clear_has_charset();
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string accept_charset = 5;
inline bool RequestHead::has_accept_charset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestHead::set_has_accept_charset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestHead::clear_has_accept_charset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestHead::clear_accept_charset() {
  if (accept_charset_ != &::google::protobuf::internal::kEmptyString) {
    accept_charset_->clear();
  }
  clear_has_accept_charset();
}
inline const ::std::string& RequestHead::accept_charset() const {
  return *accept_charset_;
}
inline void RequestHead::set_accept_charset(const ::std::string& value) {
  set_has_accept_charset();
  if (accept_charset_ == &::google::protobuf::internal::kEmptyString) {
    accept_charset_ = new ::std::string;
  }
  accept_charset_->assign(value);
}
inline void RequestHead::set_accept_charset(const char* value) {
  set_has_accept_charset();
  if (accept_charset_ == &::google::protobuf::internal::kEmptyString) {
    accept_charset_ = new ::std::string;
  }
  accept_charset_->assign(value);
}
inline void RequestHead::set_accept_charset(const char* value, size_t size) {
  set_has_accept_charset();
  if (accept_charset_ == &::google::protobuf::internal::kEmptyString) {
    accept_charset_ = new ::std::string;
  }
  accept_charset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestHead::mutable_accept_charset() {
  set_has_accept_charset();
  if (accept_charset_ == &::google::protobuf::internal::kEmptyString) {
    accept_charset_ = new ::std::string;
  }
  return accept_charset_;
}
inline ::std::string* RequestHead::release_accept_charset() {
  clear_has_accept_charset();
  if (accept_charset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accept_charset_;
    accept_charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestHead::set_allocated_accept_charset(::std::string* accept_charset) {
  if (accept_charset_ != &::google::protobuf::internal::kEmptyString) {
    delete accept_charset_;
  }
  if (accept_charset) {
    set_has_accept_charset();
    accept_charset_ = accept_charset;
  } else {
    clear_has_accept_charset();
    accept_charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string create_time = 6;
inline bool RequestHead::has_create_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestHead::set_has_create_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestHead::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestHead::clear_create_time() {
  if (create_time_ != &::google::protobuf::internal::kEmptyString) {
    create_time_->clear();
  }
  clear_has_create_time();
}
inline const ::std::string& RequestHead::create_time() const {
  return *create_time_;
}
inline void RequestHead::set_create_time(const ::std::string& value) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(value);
}
inline void RequestHead::set_create_time(const char* value) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(value);
}
inline void RequestHead::set_create_time(const char* value, size_t size) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestHead::mutable_create_time() {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  return create_time_;
}
inline ::std::string* RequestHead::release_create_time() {
  clear_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = create_time_;
    create_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestHead::set_allocated_create_time(::std::string* create_time) {
  if (create_time_ != &::google::protobuf::internal::kEmptyString) {
    delete create_time_;
  }
  if (create_time) {
    set_has_create_time();
    create_time_ = create_time;
  } else {
    clear_has_create_time();
    create_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 log_id = 7;
inline bool RequestHead::has_log_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestHead::set_has_log_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestHead::clear_has_log_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestHead::clear_log_id() {
  log_id_ = GOOGLE_ULONGLONG(0);
  clear_has_log_id();
}
inline ::google::protobuf::uint64 RequestHead::log_id() const {
  return log_id_;
}
inline void RequestHead::set_log_id(::google::protobuf::uint64 value) {
  set_has_log_id();
  log_id_ = value;
}

// optional uint32 compress_type = 8;
inline bool RequestHead::has_compress_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestHead::set_has_compress_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestHead::clear_has_compress_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestHead::clear_compress_type() {
  compress_type_ = 0u;
  clear_has_compress_type();
}
inline ::google::protobuf::uint32 RequestHead::compress_type() const {
  return compress_type_;
}
inline void RequestHead::set_compress_type(::google::protobuf::uint32 value) {
  set_has_compress_type();
  compress_type_ = value;
}

// -------------------------------------------------------------------

// RequestBody

// optional string version = 1;
inline bool RequestBody::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBody::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBody::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBody::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& RequestBody::version() const {
  return *version_;
}
inline void RequestBody::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RequestBody::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RequestBody::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBody::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* RequestBody::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestBody::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string charset = 2;
inline bool RequestBody::has_charset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestBody::set_has_charset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestBody::clear_has_charset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestBody::clear_charset() {
  if (charset_ != &::google::protobuf::internal::kEmptyString) {
    charset_->clear();
  }
  clear_has_charset();
}
inline const ::std::string& RequestBody::charset() const {
  return *charset_;
}
inline void RequestBody::set_charset(const ::std::string& value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void RequestBody::set_charset(const char* value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void RequestBody::set_charset(const char* value, size_t size) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBody::mutable_charset() {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  return charset_;
}
inline ::std::string* RequestBody::release_charset() {
  clear_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charset_;
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestBody::set_allocated_charset(::std::string* charset) {
  if (charset_ != &::google::protobuf::internal::kEmptyString) {
    delete charset_;
  }
  if (charset) {
    set_has_charset();
    charset_ = charset;
  } else {
    clear_has_charset();
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string service = 3;
inline bool RequestBody::has_service() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestBody::set_has_service() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestBody::clear_has_service() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestBody::clear_service() {
  if (service_ != &::google::protobuf::internal::kEmptyString) {
    service_->clear();
  }
  clear_has_service();
}
inline const ::std::string& RequestBody::service() const {
  return *service_;
}
inline void RequestBody::set_service(const ::std::string& value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(value);
}
inline void RequestBody::set_service(const char* value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(value);
}
inline void RequestBody::set_service(const char* value, size_t size) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBody::mutable_service() {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  return service_;
}
inline ::std::string* RequestBody::release_service() {
  clear_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_;
    service_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestBody::set_allocated_service(::std::string* service) {
  if (service_ != &::google::protobuf::internal::kEmptyString) {
    delete service_;
  }
  if (service) {
    set_has_service();
    service_ = service;
  } else {
    clear_has_service();
    service_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 method_id = 4;
inline bool RequestBody::has_method_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestBody::set_has_method_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestBody::clear_has_method_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestBody::clear_method_id() {
  method_id_ = 0u;
  clear_has_method_id();
}
inline ::google::protobuf::uint32 RequestBody::method_id() const {
  return method_id_;
}
inline void RequestBody::set_method_id(::google::protobuf::uint32 value) {
  set_has_method_id();
  method_id_ = value;
}

// required uint64 id = 5;
inline bool RequestBody::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestBody::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestBody::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestBody::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 RequestBody::id() const {
  return id_;
}
inline void RequestBody::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional bytes serialized_request = 6;
inline bool RequestBody::has_serialized_request() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestBody::set_has_serialized_request() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestBody::clear_has_serialized_request() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestBody::clear_serialized_request() {
  if (serialized_request_ != &::google::protobuf::internal::kEmptyString) {
    serialized_request_->clear();
  }
  clear_has_serialized_request();
}
inline const ::std::string& RequestBody::serialized_request() const {
  return *serialized_request_;
}
inline void RequestBody::set_serialized_request(const ::std::string& value) {
  set_has_serialized_request();
  if (serialized_request_ == &::google::protobuf::internal::kEmptyString) {
    serialized_request_ = new ::std::string;
  }
  serialized_request_->assign(value);
}
inline void RequestBody::set_serialized_request(const char* value) {
  set_has_serialized_request();
  if (serialized_request_ == &::google::protobuf::internal::kEmptyString) {
    serialized_request_ = new ::std::string;
  }
  serialized_request_->assign(value);
}
inline void RequestBody::set_serialized_request(const void* value, size_t size) {
  set_has_serialized_request();
  if (serialized_request_ == &::google::protobuf::internal::kEmptyString) {
    serialized_request_ = new ::std::string;
  }
  serialized_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBody::mutable_serialized_request() {
  set_has_serialized_request();
  if (serialized_request_ == &::google::protobuf::internal::kEmptyString) {
    serialized_request_ = new ::std::string;
  }
  return serialized_request_;
}
inline ::std::string* RequestBody::release_serialized_request() {
  clear_has_serialized_request();
  if (serialized_request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialized_request_;
    serialized_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestBody::set_allocated_serialized_request(::std::string* serialized_request) {
  if (serialized_request_ != &::google::protobuf::internal::kEmptyString) {
    delete serialized_request_;
  }
  if (serialized_request) {
    set_has_serialized_request();
    serialized_request_ = serialized_request;
  } else {
    clear_has_serialized_request();
    serialized_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PublicPbrpcResponse

// optional .brpc.policy.ResponseHead responseHead = 1;
inline bool PublicPbrpcResponse::has_responsehead() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicPbrpcResponse::set_has_responsehead() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PublicPbrpcResponse::clear_has_responsehead() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PublicPbrpcResponse::clear_responsehead() {
  if (responsehead_ != NULL) responsehead_->::brpc::policy::ResponseHead::Clear();
  clear_has_responsehead();
}
inline const ::brpc::policy::ResponseHead& PublicPbrpcResponse::responsehead() const {
  return responsehead_ != NULL ? *responsehead_ : *default_instance_->responsehead_;
}
inline ::brpc::policy::ResponseHead* PublicPbrpcResponse::mutable_responsehead() {
  set_has_responsehead();
  if (responsehead_ == NULL) responsehead_ = new ::brpc::policy::ResponseHead;
  return responsehead_;
}
inline ::brpc::policy::ResponseHead* PublicPbrpcResponse::release_responsehead() {
  clear_has_responsehead();
  ::brpc::policy::ResponseHead* temp = responsehead_;
  responsehead_ = NULL;
  return temp;
}
inline void PublicPbrpcResponse::set_allocated_responsehead(::brpc::policy::ResponseHead* responsehead) {
  delete responsehead_;
  responsehead_ = responsehead;
  if (responsehead) {
    set_has_responsehead();
  } else {
    clear_has_responsehead();
  }
}

// repeated .brpc.policy.ResponseBody responseBody = 2;
inline int PublicPbrpcResponse::responsebody_size() const {
  return responsebody_.size();
}
inline void PublicPbrpcResponse::clear_responsebody() {
  responsebody_.Clear();
}
inline const ::brpc::policy::ResponseBody& PublicPbrpcResponse::responsebody(int index) const {
  return responsebody_.Get(index);
}
inline ::brpc::policy::ResponseBody* PublicPbrpcResponse::mutable_responsebody(int index) {
  return responsebody_.Mutable(index);
}
inline ::brpc::policy::ResponseBody* PublicPbrpcResponse::add_responsebody() {
  return responsebody_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::brpc::policy::ResponseBody >&
PublicPbrpcResponse::responsebody() const {
  return responsebody_;
}
inline ::google::protobuf::RepeatedPtrField< ::brpc::policy::ResponseBody >*
PublicPbrpcResponse::mutable_responsebody() {
  return &responsebody_;
}

// -------------------------------------------------------------------

// ResponseHead

// required sint32 code = 1;
inline bool ResponseHead::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseHead::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseHead::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseHead::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ResponseHead::code() const {
  return code_;
}
inline void ResponseHead::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string text = 2;
inline bool ResponseHead::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseHead::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseHead::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseHead::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& ResponseHead::text() const {
  return *text_;
}
inline void ResponseHead::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ResponseHead::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ResponseHead::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseHead::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* ResponseHead::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseHead::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string from_host = 3;
inline bool ResponseHead::has_from_host() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseHead::set_has_from_host() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseHead::clear_has_from_host() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseHead::clear_from_host() {
  if (from_host_ != &::google::protobuf::internal::kEmptyString) {
    from_host_->clear();
  }
  clear_has_from_host();
}
inline const ::std::string& ResponseHead::from_host() const {
  return *from_host_;
}
inline void ResponseHead::set_from_host(const ::std::string& value) {
  set_has_from_host();
  if (from_host_ == &::google::protobuf::internal::kEmptyString) {
    from_host_ = new ::std::string;
  }
  from_host_->assign(value);
}
inline void ResponseHead::set_from_host(const char* value) {
  set_has_from_host();
  if (from_host_ == &::google::protobuf::internal::kEmptyString) {
    from_host_ = new ::std::string;
  }
  from_host_->assign(value);
}
inline void ResponseHead::set_from_host(const char* value, size_t size) {
  set_has_from_host();
  if (from_host_ == &::google::protobuf::internal::kEmptyString) {
    from_host_ = new ::std::string;
  }
  from_host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseHead::mutable_from_host() {
  set_has_from_host();
  if (from_host_ == &::google::protobuf::internal::kEmptyString) {
    from_host_ = new ::std::string;
  }
  return from_host_;
}
inline ::std::string* ResponseHead::release_from_host() {
  clear_has_from_host();
  if (from_host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_host_;
    from_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseHead::set_allocated_from_host(::std::string* from_host) {
  if (from_host_ != &::google::protobuf::internal::kEmptyString) {
    delete from_host_;
  }
  if (from_host) {
    set_has_from_host();
    from_host_ = from_host;
  } else {
    clear_has_from_host();
    from_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 compress_type = 4;
inline bool ResponseHead::has_compress_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseHead::set_has_compress_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseHead::clear_has_compress_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseHead::clear_compress_type() {
  compress_type_ = 0u;
  clear_has_compress_type();
}
inline ::google::protobuf::uint32 ResponseHead::compress_type() const {
  return compress_type_;
}
inline void ResponseHead::set_compress_type(::google::protobuf::uint32 value) {
  set_has_compress_type();
  compress_type_ = value;
}

// -------------------------------------------------------------------

// ResponseBody

// optional bytes serialized_response = 1;
inline bool ResponseBody::has_serialized_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseBody::set_has_serialized_response() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseBody::clear_has_serialized_response() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseBody::clear_serialized_response() {
  if (serialized_response_ != &::google::protobuf::internal::kEmptyString) {
    serialized_response_->clear();
  }
  clear_has_serialized_response();
}
inline const ::std::string& ResponseBody::serialized_response() const {
  return *serialized_response_;
}
inline void ResponseBody::set_serialized_response(const ::std::string& value) {
  set_has_serialized_response();
  if (serialized_response_ == &::google::protobuf::internal::kEmptyString) {
    serialized_response_ = new ::std::string;
  }
  serialized_response_->assign(value);
}
inline void ResponseBody::set_serialized_response(const char* value) {
  set_has_serialized_response();
  if (serialized_response_ == &::google::protobuf::internal::kEmptyString) {
    serialized_response_ = new ::std::string;
  }
  serialized_response_->assign(value);
}
inline void ResponseBody::set_serialized_response(const void* value, size_t size) {
  set_has_serialized_response();
  if (serialized_response_ == &::google::protobuf::internal::kEmptyString) {
    serialized_response_ = new ::std::string;
  }
  serialized_response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseBody::mutable_serialized_response() {
  set_has_serialized_response();
  if (serialized_response_ == &::google::protobuf::internal::kEmptyString) {
    serialized_response_ = new ::std::string;
  }
  return serialized_response_;
}
inline ::std::string* ResponseBody::release_serialized_response() {
  clear_has_serialized_response();
  if (serialized_response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialized_response_;
    serialized_response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseBody::set_allocated_serialized_response(::std::string* serialized_response) {
  if (serialized_response_ != &::google::protobuf::internal::kEmptyString) {
    delete serialized_response_;
  }
  if (serialized_response) {
    set_has_serialized_response();
    serialized_response_ = serialized_response;
  } else {
    clear_has_serialized_response();
    serialized_response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 2;
inline bool ResponseBody::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseBody::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseBody::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseBody::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ResponseBody::version() const {
  return *version_;
}
inline void ResponseBody::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ResponseBody::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ResponseBody::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseBody::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* ResponseBody::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseBody::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 error = 3;
inline bool ResponseBody::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseBody::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseBody::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseBody::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::google::protobuf::int32 ResponseBody::error() const {
  return error_;
}
inline void ResponseBody::set_error(::google::protobuf::int32 value) {
  set_has_error();
  error_ = value;
}

// required uint64 id = 4;
inline bool ResponseBody::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseBody::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseBody::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseBody::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 ResponseBody::id() const {
  return id_;
}
inline void ResponseBody::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace policy
}  // namespace brpc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_brpc_2fpolicy_2fpublic_5fpbrpc_5fmeta_2eproto__INCLUDED
