// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: brpc/rtmp.proto

#ifndef PROTOBUF_brpc_2frtmp_2eproto__INCLUDED
#define PROTOBUF_brpc_2frtmp_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace brpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_brpc_2frtmp_2eproto();
void protobuf_AssignDesc_brpc_2frtmp_2eproto();
void protobuf_ShutdownFile_brpc_2frtmp_2eproto();

class RtmpConnectRequest;
class RtmpConnectResponse;
class RtmpPlay2Options;
class RtmpInfo;
class RtmpEmptyObject;

// ===================================================================

class RtmpConnectRequest : public ::google::protobuf::Message {
 public:
  RtmpConnectRequest();
  virtual ~RtmpConnectRequest();

  RtmpConnectRequest(const RtmpConnectRequest& from);

  inline RtmpConnectRequest& operator=(const RtmpConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RtmpConnectRequest& default_instance();

  void Swap(RtmpConnectRequest* other);

  // implements Message ----------------------------------------------

  RtmpConnectRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtmpConnectRequest& from);
  void MergeFrom(const RtmpConnectRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string app = 1;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 1;
  inline const ::std::string& app() const;
  inline void set_app(const ::std::string& value);
  inline void set_app(const char* value);
  inline void set_app(const char* value, size_t size);
  inline ::std::string* mutable_app();
  inline ::std::string* release_app();
  inline void set_allocated_app(::std::string* app);

  // optional string flashVer = 2;
  inline bool has_flashver() const;
  inline void clear_flashver();
  static const int kFlashVerFieldNumber = 2;
  inline const ::std::string& flashver() const;
  inline void set_flashver(const ::std::string& value);
  inline void set_flashver(const char* value);
  inline void set_flashver(const char* value, size_t size);
  inline ::std::string* mutable_flashver();
  inline ::std::string* release_flashver();
  inline void set_allocated_flashver(::std::string* flashver);

  // optional string swfUrl = 3;
  inline bool has_swfurl() const;
  inline void clear_swfurl();
  static const int kSwfUrlFieldNumber = 3;
  inline const ::std::string& swfurl() const;
  inline void set_swfurl(const ::std::string& value);
  inline void set_swfurl(const char* value);
  inline void set_swfurl(const char* value, size_t size);
  inline ::std::string* mutable_swfurl();
  inline ::std::string* release_swfurl();
  inline void set_allocated_swfurl(::std::string* swfurl);

  // optional string tcUrl = 4;
  inline bool has_tcurl() const;
  inline void clear_tcurl();
  static const int kTcUrlFieldNumber = 4;
  inline const ::std::string& tcurl() const;
  inline void set_tcurl(const ::std::string& value);
  inline void set_tcurl(const char* value);
  inline void set_tcurl(const char* value, size_t size);
  inline ::std::string* mutable_tcurl();
  inline ::std::string* release_tcurl();
  inline void set_allocated_tcurl(::std::string* tcurl);

  // optional bool fpad = 5;
  inline bool has_fpad() const;
  inline void clear_fpad();
  static const int kFpadFieldNumber = 5;
  inline bool fpad() const;
  inline void set_fpad(bool value);

  // optional double capabilities = 6;
  inline bool has_capabilities() const;
  inline void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 6;
  inline double capabilities() const;
  inline void set_capabilities(double value);

  // optional double audioCodecs = 7;
  inline bool has_audiocodecs() const;
  inline void clear_audiocodecs();
  static const int kAudioCodecsFieldNumber = 7;
  inline double audiocodecs() const;
  inline void set_audiocodecs(double value);

  // optional double videoCodecs = 8;
  inline bool has_videocodecs() const;
  inline void clear_videocodecs();
  static const int kVideoCodecsFieldNumber = 8;
  inline double videocodecs() const;
  inline void set_videocodecs(double value);

  // optional double videoFunction = 9;
  inline bool has_videofunction() const;
  inline void clear_videofunction();
  static const int kVideoFunctionFieldNumber = 9;
  inline double videofunction() const;
  inline void set_videofunction(double value);

  // optional string pageUrl = 10;
  inline bool has_pageurl() const;
  inline void clear_pageurl();
  static const int kPageUrlFieldNumber = 10;
  inline const ::std::string& pageurl() const;
  inline void set_pageurl(const ::std::string& value);
  inline void set_pageurl(const char* value);
  inline void set_pageurl(const char* value, size_t size);
  inline ::std::string* mutable_pageurl();
  inline ::std::string* release_pageurl();
  inline void set_allocated_pageurl(::std::string* pageurl);

  // optional double objectEncoding = 11;
  inline bool has_objectencoding() const;
  inline void clear_objectencoding();
  static const int kObjectEncodingFieldNumber = 11;
  inline double objectencoding() const;
  inline void set_objectencoding(double value);

  // optional bool stream_multiplexing = 12;
  inline bool has_stream_multiplexing() const;
  inline void clear_stream_multiplexing();
  static const int kStreamMultiplexingFieldNumber = 12;
  inline bool stream_multiplexing() const;
  inline void set_stream_multiplexing(bool value);

  // @@protoc_insertion_point(class_scope:brpc.RtmpConnectRequest)
 private:
  inline void set_has_app();
  inline void clear_has_app();
  inline void set_has_flashver();
  inline void clear_has_flashver();
  inline void set_has_swfurl();
  inline void clear_has_swfurl();
  inline void set_has_tcurl();
  inline void clear_has_tcurl();
  inline void set_has_fpad();
  inline void clear_has_fpad();
  inline void set_has_capabilities();
  inline void clear_has_capabilities();
  inline void set_has_audiocodecs();
  inline void clear_has_audiocodecs();
  inline void set_has_videocodecs();
  inline void clear_has_videocodecs();
  inline void set_has_videofunction();
  inline void clear_has_videofunction();
  inline void set_has_pageurl();
  inline void clear_has_pageurl();
  inline void set_has_objectencoding();
  inline void clear_has_objectencoding();
  inline void set_has_stream_multiplexing();
  inline void clear_has_stream_multiplexing();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* app_;
  ::std::string* flashver_;
  ::std::string* swfurl_;
  ::std::string* tcurl_;
  double capabilities_;
  double audiocodecs_;
  double videocodecs_;
  double videofunction_;
  ::std::string* pageurl_;
  double objectencoding_;
  bool fpad_;
  bool stream_multiplexing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_brpc_2frtmp_2eproto();
  friend void protobuf_AssignDesc_brpc_2frtmp_2eproto();
  friend void protobuf_ShutdownFile_brpc_2frtmp_2eproto();

  void InitAsDefaultInstance();
  static RtmpConnectRequest* default_instance_;
};
// -------------------------------------------------------------------

class RtmpConnectResponse : public ::google::protobuf::Message {
 public:
  RtmpConnectResponse();
  virtual ~RtmpConnectResponse();

  RtmpConnectResponse(const RtmpConnectResponse& from);

  inline RtmpConnectResponse& operator=(const RtmpConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RtmpConnectResponse& default_instance();

  void Swap(RtmpConnectResponse* other);

  // implements Message ----------------------------------------------

  RtmpConnectResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtmpConnectResponse& from);
  void MergeFrom(const RtmpConnectResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fmsVer = 1;
  inline bool has_fmsver() const;
  inline void clear_fmsver();
  static const int kFmsVerFieldNumber = 1;
  inline const ::std::string& fmsver() const;
  inline void set_fmsver(const ::std::string& value);
  inline void set_fmsver(const char* value);
  inline void set_fmsver(const char* value, size_t size);
  inline ::std::string* mutable_fmsver();
  inline ::std::string* release_fmsver();
  inline void set_allocated_fmsver(::std::string* fmsver);

  // optional double capabilities = 2;
  inline bool has_capabilities() const;
  inline void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 2;
  inline double capabilities() const;
  inline void set_capabilities(double value);

  // optional double mode = 3;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 3;
  inline double mode() const;
  inline void set_mode(double value);

  // optional bool create_stream_with_play_or_publish = 4;
  inline bool has_create_stream_with_play_or_publish() const;
  inline void clear_create_stream_with_play_or_publish();
  static const int kCreateStreamWithPlayOrPublishFieldNumber = 4;
  inline bool create_stream_with_play_or_publish() const;
  inline void set_create_stream_with_play_or_publish(bool value);

  // @@protoc_insertion_point(class_scope:brpc.RtmpConnectResponse)
 private:
  inline void set_has_fmsver();
  inline void clear_has_fmsver();
  inline void set_has_capabilities();
  inline void clear_has_capabilities();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_create_stream_with_play_or_publish();
  inline void clear_has_create_stream_with_play_or_publish();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fmsver_;
  double capabilities_;
  double mode_;
  bool create_stream_with_play_or_publish_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_brpc_2frtmp_2eproto();
  friend void protobuf_AssignDesc_brpc_2frtmp_2eproto();
  friend void protobuf_ShutdownFile_brpc_2frtmp_2eproto();

  void InitAsDefaultInstance();
  static RtmpConnectResponse* default_instance_;
};
// -------------------------------------------------------------------

class RtmpPlay2Options : public ::google::protobuf::Message {
 public:
  RtmpPlay2Options();
  virtual ~RtmpPlay2Options();

  RtmpPlay2Options(const RtmpPlay2Options& from);

  inline RtmpPlay2Options& operator=(const RtmpPlay2Options& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RtmpPlay2Options& default_instance();

  void Swap(RtmpPlay2Options* other);

  // implements Message ----------------------------------------------

  RtmpPlay2Options* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtmpPlay2Options& from);
  void MergeFrom(const RtmpPlay2Options& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double len = 1;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 1;
  inline double len() const;
  inline void set_len(double value);

  // optional double offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline double offset() const;
  inline void set_offset(double value);

  // optional string oldStreamName = 3;
  inline bool has_oldstreamname() const;
  inline void clear_oldstreamname();
  static const int kOldStreamNameFieldNumber = 3;
  inline const ::std::string& oldstreamname() const;
  inline void set_oldstreamname(const ::std::string& value);
  inline void set_oldstreamname(const char* value);
  inline void set_oldstreamname(const char* value, size_t size);
  inline ::std::string* mutable_oldstreamname();
  inline ::std::string* release_oldstreamname();
  inline void set_allocated_oldstreamname(::std::string* oldstreamname);

  // optional double start = 4;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 4;
  inline double start() const;
  inline void set_start(double value);

  // optional string streamName = 5;
  inline bool has_streamname() const;
  inline void clear_streamname();
  static const int kStreamNameFieldNumber = 5;
  inline const ::std::string& streamname() const;
  inline void set_streamname(const ::std::string& value);
  inline void set_streamname(const char* value);
  inline void set_streamname(const char* value, size_t size);
  inline ::std::string* mutable_streamname();
  inline ::std::string* release_streamname();
  inline void set_allocated_streamname(::std::string* streamname);

  // optional string transition = 6;
  inline bool has_transition() const;
  inline void clear_transition();
  static const int kTransitionFieldNumber = 6;
  inline const ::std::string& transition() const;
  inline void set_transition(const ::std::string& value);
  inline void set_transition(const char* value);
  inline void set_transition(const char* value, size_t size);
  inline ::std::string* mutable_transition();
  inline ::std::string* release_transition();
  inline void set_allocated_transition(::std::string* transition);

  // @@protoc_insertion_point(class_scope:brpc.RtmpPlay2Options)
 private:
  inline void set_has_len();
  inline void clear_has_len();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_oldstreamname();
  inline void clear_has_oldstreamname();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_streamname();
  inline void clear_has_streamname();
  inline void set_has_transition();
  inline void clear_has_transition();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double len_;
  double offset_;
  ::std::string* oldstreamname_;
  double start_;
  ::std::string* streamname_;
  ::std::string* transition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_brpc_2frtmp_2eproto();
  friend void protobuf_AssignDesc_brpc_2frtmp_2eproto();
  friend void protobuf_ShutdownFile_brpc_2frtmp_2eproto();

  void InitAsDefaultInstance();
  static RtmpPlay2Options* default_instance_;
};
// -------------------------------------------------------------------

class RtmpInfo : public ::google::protobuf::Message {
 public:
  RtmpInfo();
  virtual ~RtmpInfo();

  RtmpInfo(const RtmpInfo& from);

  inline RtmpInfo& operator=(const RtmpInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RtmpInfo& default_instance();

  void Swap(RtmpInfo* other);

  // implements Message ----------------------------------------------

  RtmpInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtmpInfo& from);
  void MergeFrom(const RtmpInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // optional string level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline const ::std::string& level() const;
  inline void set_level(const ::std::string& value);
  inline void set_level(const char* value);
  inline void set_level(const char* value, size_t size);
  inline ::std::string* mutable_level();
  inline ::std::string* release_level();
  inline void set_allocated_level(::std::string* level);

  // optional string description = 3;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 3;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional double objectEncoding = 4;
  inline bool has_objectencoding() const;
  inline void clear_objectencoding();
  static const int kObjectEncodingFieldNumber = 4;
  inline double objectencoding() const;
  inline void set_objectencoding(double value);

  // @@protoc_insertion_point(class_scope:brpc.RtmpInfo)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_objectencoding();
  inline void clear_has_objectencoding();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* code_;
  ::std::string* level_;
  ::std::string* description_;
  double objectencoding_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_brpc_2frtmp_2eproto();
  friend void protobuf_AssignDesc_brpc_2frtmp_2eproto();
  friend void protobuf_ShutdownFile_brpc_2frtmp_2eproto();

  void InitAsDefaultInstance();
  static RtmpInfo* default_instance_;
};
// -------------------------------------------------------------------

class RtmpEmptyObject : public ::google::protobuf::Message {
 public:
  RtmpEmptyObject();
  virtual ~RtmpEmptyObject();

  RtmpEmptyObject(const RtmpEmptyObject& from);

  inline RtmpEmptyObject& operator=(const RtmpEmptyObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RtmpEmptyObject& default_instance();

  void Swap(RtmpEmptyObject* other);

  // implements Message ----------------------------------------------

  RtmpEmptyObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtmpEmptyObject& from);
  void MergeFrom(const RtmpEmptyObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:brpc.RtmpEmptyObject)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_brpc_2frtmp_2eproto();
  friend void protobuf_AssignDesc_brpc_2frtmp_2eproto();
  friend void protobuf_ShutdownFile_brpc_2frtmp_2eproto();

  void InitAsDefaultInstance();
  static RtmpEmptyObject* default_instance_;
};
// ===================================================================


// ===================================================================

// RtmpConnectRequest

// optional string app = 1;
inline bool RtmpConnectRequest::has_app() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtmpConnectRequest::set_has_app() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtmpConnectRequest::clear_has_app() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtmpConnectRequest::clear_app() {
  if (app_ != &::google::protobuf::internal::kEmptyString) {
    app_->clear();
  }
  clear_has_app();
}
inline const ::std::string& RtmpConnectRequest::app() const {
  return *app_;
}
inline void RtmpConnectRequest::set_app(const ::std::string& value) {
  set_has_app();
  if (app_ == &::google::protobuf::internal::kEmptyString) {
    app_ = new ::std::string;
  }
  app_->assign(value);
}
inline void RtmpConnectRequest::set_app(const char* value) {
  set_has_app();
  if (app_ == &::google::protobuf::internal::kEmptyString) {
    app_ = new ::std::string;
  }
  app_->assign(value);
}
inline void RtmpConnectRequest::set_app(const char* value, size_t size) {
  set_has_app();
  if (app_ == &::google::protobuf::internal::kEmptyString) {
    app_ = new ::std::string;
  }
  app_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtmpConnectRequest::mutable_app() {
  set_has_app();
  if (app_ == &::google::protobuf::internal::kEmptyString) {
    app_ = new ::std::string;
  }
  return app_;
}
inline ::std::string* RtmpConnectRequest::release_app() {
  clear_has_app();
  if (app_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_;
    app_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RtmpConnectRequest::set_allocated_app(::std::string* app) {
  if (app_ != &::google::protobuf::internal::kEmptyString) {
    delete app_;
  }
  if (app) {
    set_has_app();
    app_ = app;
  } else {
    clear_has_app();
    app_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string flashVer = 2;
inline bool RtmpConnectRequest::has_flashver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtmpConnectRequest::set_has_flashver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtmpConnectRequest::clear_has_flashver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtmpConnectRequest::clear_flashver() {
  if (flashver_ != &::google::protobuf::internal::kEmptyString) {
    flashver_->clear();
  }
  clear_has_flashver();
}
inline const ::std::string& RtmpConnectRequest::flashver() const {
  return *flashver_;
}
inline void RtmpConnectRequest::set_flashver(const ::std::string& value) {
  set_has_flashver();
  if (flashver_ == &::google::protobuf::internal::kEmptyString) {
    flashver_ = new ::std::string;
  }
  flashver_->assign(value);
}
inline void RtmpConnectRequest::set_flashver(const char* value) {
  set_has_flashver();
  if (flashver_ == &::google::protobuf::internal::kEmptyString) {
    flashver_ = new ::std::string;
  }
  flashver_->assign(value);
}
inline void RtmpConnectRequest::set_flashver(const char* value, size_t size) {
  set_has_flashver();
  if (flashver_ == &::google::protobuf::internal::kEmptyString) {
    flashver_ = new ::std::string;
  }
  flashver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtmpConnectRequest::mutable_flashver() {
  set_has_flashver();
  if (flashver_ == &::google::protobuf::internal::kEmptyString) {
    flashver_ = new ::std::string;
  }
  return flashver_;
}
inline ::std::string* RtmpConnectRequest::release_flashver() {
  clear_has_flashver();
  if (flashver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flashver_;
    flashver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RtmpConnectRequest::set_allocated_flashver(::std::string* flashver) {
  if (flashver_ != &::google::protobuf::internal::kEmptyString) {
    delete flashver_;
  }
  if (flashver) {
    set_has_flashver();
    flashver_ = flashver;
  } else {
    clear_has_flashver();
    flashver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string swfUrl = 3;
inline bool RtmpConnectRequest::has_swfurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtmpConnectRequest::set_has_swfurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtmpConnectRequest::clear_has_swfurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtmpConnectRequest::clear_swfurl() {
  if (swfurl_ != &::google::protobuf::internal::kEmptyString) {
    swfurl_->clear();
  }
  clear_has_swfurl();
}
inline const ::std::string& RtmpConnectRequest::swfurl() const {
  return *swfurl_;
}
inline void RtmpConnectRequest::set_swfurl(const ::std::string& value) {
  set_has_swfurl();
  if (swfurl_ == &::google::protobuf::internal::kEmptyString) {
    swfurl_ = new ::std::string;
  }
  swfurl_->assign(value);
}
inline void RtmpConnectRequest::set_swfurl(const char* value) {
  set_has_swfurl();
  if (swfurl_ == &::google::protobuf::internal::kEmptyString) {
    swfurl_ = new ::std::string;
  }
  swfurl_->assign(value);
}
inline void RtmpConnectRequest::set_swfurl(const char* value, size_t size) {
  set_has_swfurl();
  if (swfurl_ == &::google::protobuf::internal::kEmptyString) {
    swfurl_ = new ::std::string;
  }
  swfurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtmpConnectRequest::mutable_swfurl() {
  set_has_swfurl();
  if (swfurl_ == &::google::protobuf::internal::kEmptyString) {
    swfurl_ = new ::std::string;
  }
  return swfurl_;
}
inline ::std::string* RtmpConnectRequest::release_swfurl() {
  clear_has_swfurl();
  if (swfurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = swfurl_;
    swfurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RtmpConnectRequest::set_allocated_swfurl(::std::string* swfurl) {
  if (swfurl_ != &::google::protobuf::internal::kEmptyString) {
    delete swfurl_;
  }
  if (swfurl) {
    set_has_swfurl();
    swfurl_ = swfurl;
  } else {
    clear_has_swfurl();
    swfurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tcUrl = 4;
inline bool RtmpConnectRequest::has_tcurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtmpConnectRequest::set_has_tcurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtmpConnectRequest::clear_has_tcurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtmpConnectRequest::clear_tcurl() {
  if (tcurl_ != &::google::protobuf::internal::kEmptyString) {
    tcurl_->clear();
  }
  clear_has_tcurl();
}
inline const ::std::string& RtmpConnectRequest::tcurl() const {
  return *tcurl_;
}
inline void RtmpConnectRequest::set_tcurl(const ::std::string& value) {
  set_has_tcurl();
  if (tcurl_ == &::google::protobuf::internal::kEmptyString) {
    tcurl_ = new ::std::string;
  }
  tcurl_->assign(value);
}
inline void RtmpConnectRequest::set_tcurl(const char* value) {
  set_has_tcurl();
  if (tcurl_ == &::google::protobuf::internal::kEmptyString) {
    tcurl_ = new ::std::string;
  }
  tcurl_->assign(value);
}
inline void RtmpConnectRequest::set_tcurl(const char* value, size_t size) {
  set_has_tcurl();
  if (tcurl_ == &::google::protobuf::internal::kEmptyString) {
    tcurl_ = new ::std::string;
  }
  tcurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtmpConnectRequest::mutable_tcurl() {
  set_has_tcurl();
  if (tcurl_ == &::google::protobuf::internal::kEmptyString) {
    tcurl_ = new ::std::string;
  }
  return tcurl_;
}
inline ::std::string* RtmpConnectRequest::release_tcurl() {
  clear_has_tcurl();
  if (tcurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tcurl_;
    tcurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RtmpConnectRequest::set_allocated_tcurl(::std::string* tcurl) {
  if (tcurl_ != &::google::protobuf::internal::kEmptyString) {
    delete tcurl_;
  }
  if (tcurl) {
    set_has_tcurl();
    tcurl_ = tcurl;
  } else {
    clear_has_tcurl();
    tcurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool fpad = 5;
inline bool RtmpConnectRequest::has_fpad() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RtmpConnectRequest::set_has_fpad() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RtmpConnectRequest::clear_has_fpad() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RtmpConnectRequest::clear_fpad() {
  fpad_ = false;
  clear_has_fpad();
}
inline bool RtmpConnectRequest::fpad() const {
  return fpad_;
}
inline void RtmpConnectRequest::set_fpad(bool value) {
  set_has_fpad();
  fpad_ = value;
}

// optional double capabilities = 6;
inline bool RtmpConnectRequest::has_capabilities() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RtmpConnectRequest::set_has_capabilities() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RtmpConnectRequest::clear_has_capabilities() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RtmpConnectRequest::clear_capabilities() {
  capabilities_ = 0;
  clear_has_capabilities();
}
inline double RtmpConnectRequest::capabilities() const {
  return capabilities_;
}
inline void RtmpConnectRequest::set_capabilities(double value) {
  set_has_capabilities();
  capabilities_ = value;
}

// optional double audioCodecs = 7;
inline bool RtmpConnectRequest::has_audiocodecs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RtmpConnectRequest::set_has_audiocodecs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RtmpConnectRequest::clear_has_audiocodecs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RtmpConnectRequest::clear_audiocodecs() {
  audiocodecs_ = 0;
  clear_has_audiocodecs();
}
inline double RtmpConnectRequest::audiocodecs() const {
  return audiocodecs_;
}
inline void RtmpConnectRequest::set_audiocodecs(double value) {
  set_has_audiocodecs();
  audiocodecs_ = value;
}

// optional double videoCodecs = 8;
inline bool RtmpConnectRequest::has_videocodecs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RtmpConnectRequest::set_has_videocodecs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RtmpConnectRequest::clear_has_videocodecs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RtmpConnectRequest::clear_videocodecs() {
  videocodecs_ = 0;
  clear_has_videocodecs();
}
inline double RtmpConnectRequest::videocodecs() const {
  return videocodecs_;
}
inline void RtmpConnectRequest::set_videocodecs(double value) {
  set_has_videocodecs();
  videocodecs_ = value;
}

// optional double videoFunction = 9;
inline bool RtmpConnectRequest::has_videofunction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RtmpConnectRequest::set_has_videofunction() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RtmpConnectRequest::clear_has_videofunction() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RtmpConnectRequest::clear_videofunction() {
  videofunction_ = 0;
  clear_has_videofunction();
}
inline double RtmpConnectRequest::videofunction() const {
  return videofunction_;
}
inline void RtmpConnectRequest::set_videofunction(double value) {
  set_has_videofunction();
  videofunction_ = value;
}

// optional string pageUrl = 10;
inline bool RtmpConnectRequest::has_pageurl() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RtmpConnectRequest::set_has_pageurl() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RtmpConnectRequest::clear_has_pageurl() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RtmpConnectRequest::clear_pageurl() {
  if (pageurl_ != &::google::protobuf::internal::kEmptyString) {
    pageurl_->clear();
  }
  clear_has_pageurl();
}
inline const ::std::string& RtmpConnectRequest::pageurl() const {
  return *pageurl_;
}
inline void RtmpConnectRequest::set_pageurl(const ::std::string& value) {
  set_has_pageurl();
  if (pageurl_ == &::google::protobuf::internal::kEmptyString) {
    pageurl_ = new ::std::string;
  }
  pageurl_->assign(value);
}
inline void RtmpConnectRequest::set_pageurl(const char* value) {
  set_has_pageurl();
  if (pageurl_ == &::google::protobuf::internal::kEmptyString) {
    pageurl_ = new ::std::string;
  }
  pageurl_->assign(value);
}
inline void RtmpConnectRequest::set_pageurl(const char* value, size_t size) {
  set_has_pageurl();
  if (pageurl_ == &::google::protobuf::internal::kEmptyString) {
    pageurl_ = new ::std::string;
  }
  pageurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtmpConnectRequest::mutable_pageurl() {
  set_has_pageurl();
  if (pageurl_ == &::google::protobuf::internal::kEmptyString) {
    pageurl_ = new ::std::string;
  }
  return pageurl_;
}
inline ::std::string* RtmpConnectRequest::release_pageurl() {
  clear_has_pageurl();
  if (pageurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pageurl_;
    pageurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RtmpConnectRequest::set_allocated_pageurl(::std::string* pageurl) {
  if (pageurl_ != &::google::protobuf::internal::kEmptyString) {
    delete pageurl_;
  }
  if (pageurl) {
    set_has_pageurl();
    pageurl_ = pageurl;
  } else {
    clear_has_pageurl();
    pageurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double objectEncoding = 11;
inline bool RtmpConnectRequest::has_objectencoding() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RtmpConnectRequest::set_has_objectencoding() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RtmpConnectRequest::clear_has_objectencoding() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RtmpConnectRequest::clear_objectencoding() {
  objectencoding_ = 0;
  clear_has_objectencoding();
}
inline double RtmpConnectRequest::objectencoding() const {
  return objectencoding_;
}
inline void RtmpConnectRequest::set_objectencoding(double value) {
  set_has_objectencoding();
  objectencoding_ = value;
}

// optional bool stream_multiplexing = 12;
inline bool RtmpConnectRequest::has_stream_multiplexing() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RtmpConnectRequest::set_has_stream_multiplexing() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RtmpConnectRequest::clear_has_stream_multiplexing() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RtmpConnectRequest::clear_stream_multiplexing() {
  stream_multiplexing_ = false;
  clear_has_stream_multiplexing();
}
inline bool RtmpConnectRequest::stream_multiplexing() const {
  return stream_multiplexing_;
}
inline void RtmpConnectRequest::set_stream_multiplexing(bool value) {
  set_has_stream_multiplexing();
  stream_multiplexing_ = value;
}

// -------------------------------------------------------------------

// RtmpConnectResponse

// optional string fmsVer = 1;
inline bool RtmpConnectResponse::has_fmsver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtmpConnectResponse::set_has_fmsver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtmpConnectResponse::clear_has_fmsver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtmpConnectResponse::clear_fmsver() {
  if (fmsver_ != &::google::protobuf::internal::kEmptyString) {
    fmsver_->clear();
  }
  clear_has_fmsver();
}
inline const ::std::string& RtmpConnectResponse::fmsver() const {
  return *fmsver_;
}
inline void RtmpConnectResponse::set_fmsver(const ::std::string& value) {
  set_has_fmsver();
  if (fmsver_ == &::google::protobuf::internal::kEmptyString) {
    fmsver_ = new ::std::string;
  }
  fmsver_->assign(value);
}
inline void RtmpConnectResponse::set_fmsver(const char* value) {
  set_has_fmsver();
  if (fmsver_ == &::google::protobuf::internal::kEmptyString) {
    fmsver_ = new ::std::string;
  }
  fmsver_->assign(value);
}
inline void RtmpConnectResponse::set_fmsver(const char* value, size_t size) {
  set_has_fmsver();
  if (fmsver_ == &::google::protobuf::internal::kEmptyString) {
    fmsver_ = new ::std::string;
  }
  fmsver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtmpConnectResponse::mutable_fmsver() {
  set_has_fmsver();
  if (fmsver_ == &::google::protobuf::internal::kEmptyString) {
    fmsver_ = new ::std::string;
  }
  return fmsver_;
}
inline ::std::string* RtmpConnectResponse::release_fmsver() {
  clear_has_fmsver();
  if (fmsver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fmsver_;
    fmsver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RtmpConnectResponse::set_allocated_fmsver(::std::string* fmsver) {
  if (fmsver_ != &::google::protobuf::internal::kEmptyString) {
    delete fmsver_;
  }
  if (fmsver) {
    set_has_fmsver();
    fmsver_ = fmsver;
  } else {
    clear_has_fmsver();
    fmsver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double capabilities = 2;
inline bool RtmpConnectResponse::has_capabilities() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtmpConnectResponse::set_has_capabilities() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtmpConnectResponse::clear_has_capabilities() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtmpConnectResponse::clear_capabilities() {
  capabilities_ = 0;
  clear_has_capabilities();
}
inline double RtmpConnectResponse::capabilities() const {
  return capabilities_;
}
inline void RtmpConnectResponse::set_capabilities(double value) {
  set_has_capabilities();
  capabilities_ = value;
}

// optional double mode = 3;
inline bool RtmpConnectResponse::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtmpConnectResponse::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtmpConnectResponse::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtmpConnectResponse::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline double RtmpConnectResponse::mode() const {
  return mode_;
}
inline void RtmpConnectResponse::set_mode(double value) {
  set_has_mode();
  mode_ = value;
}

// optional bool create_stream_with_play_or_publish = 4;
inline bool RtmpConnectResponse::has_create_stream_with_play_or_publish() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtmpConnectResponse::set_has_create_stream_with_play_or_publish() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtmpConnectResponse::clear_has_create_stream_with_play_or_publish() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtmpConnectResponse::clear_create_stream_with_play_or_publish() {
  create_stream_with_play_or_publish_ = false;
  clear_has_create_stream_with_play_or_publish();
}
inline bool RtmpConnectResponse::create_stream_with_play_or_publish() const {
  return create_stream_with_play_or_publish_;
}
inline void RtmpConnectResponse::set_create_stream_with_play_or_publish(bool value) {
  set_has_create_stream_with_play_or_publish();
  create_stream_with_play_or_publish_ = value;
}

// -------------------------------------------------------------------

// RtmpPlay2Options

// optional double len = 1;
inline bool RtmpPlay2Options::has_len() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtmpPlay2Options::set_has_len() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtmpPlay2Options::clear_has_len() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtmpPlay2Options::clear_len() {
  len_ = 0;
  clear_has_len();
}
inline double RtmpPlay2Options::len() const {
  return len_;
}
inline void RtmpPlay2Options::set_len(double value) {
  set_has_len();
  len_ = value;
}

// optional double offset = 2;
inline bool RtmpPlay2Options::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtmpPlay2Options::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtmpPlay2Options::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtmpPlay2Options::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline double RtmpPlay2Options::offset() const {
  return offset_;
}
inline void RtmpPlay2Options::set_offset(double value) {
  set_has_offset();
  offset_ = value;
}

// optional string oldStreamName = 3;
inline bool RtmpPlay2Options::has_oldstreamname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtmpPlay2Options::set_has_oldstreamname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtmpPlay2Options::clear_has_oldstreamname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtmpPlay2Options::clear_oldstreamname() {
  if (oldstreamname_ != &::google::protobuf::internal::kEmptyString) {
    oldstreamname_->clear();
  }
  clear_has_oldstreamname();
}
inline const ::std::string& RtmpPlay2Options::oldstreamname() const {
  return *oldstreamname_;
}
inline void RtmpPlay2Options::set_oldstreamname(const ::std::string& value) {
  set_has_oldstreamname();
  if (oldstreamname_ == &::google::protobuf::internal::kEmptyString) {
    oldstreamname_ = new ::std::string;
  }
  oldstreamname_->assign(value);
}
inline void RtmpPlay2Options::set_oldstreamname(const char* value) {
  set_has_oldstreamname();
  if (oldstreamname_ == &::google::protobuf::internal::kEmptyString) {
    oldstreamname_ = new ::std::string;
  }
  oldstreamname_->assign(value);
}
inline void RtmpPlay2Options::set_oldstreamname(const char* value, size_t size) {
  set_has_oldstreamname();
  if (oldstreamname_ == &::google::protobuf::internal::kEmptyString) {
    oldstreamname_ = new ::std::string;
  }
  oldstreamname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtmpPlay2Options::mutable_oldstreamname() {
  set_has_oldstreamname();
  if (oldstreamname_ == &::google::protobuf::internal::kEmptyString) {
    oldstreamname_ = new ::std::string;
  }
  return oldstreamname_;
}
inline ::std::string* RtmpPlay2Options::release_oldstreamname() {
  clear_has_oldstreamname();
  if (oldstreamname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldstreamname_;
    oldstreamname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RtmpPlay2Options::set_allocated_oldstreamname(::std::string* oldstreamname) {
  if (oldstreamname_ != &::google::protobuf::internal::kEmptyString) {
    delete oldstreamname_;
  }
  if (oldstreamname) {
    set_has_oldstreamname();
    oldstreamname_ = oldstreamname;
  } else {
    clear_has_oldstreamname();
    oldstreamname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double start = 4;
inline bool RtmpPlay2Options::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtmpPlay2Options::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtmpPlay2Options::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtmpPlay2Options::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline double RtmpPlay2Options::start() const {
  return start_;
}
inline void RtmpPlay2Options::set_start(double value) {
  set_has_start();
  start_ = value;
}

// optional string streamName = 5;
inline bool RtmpPlay2Options::has_streamname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RtmpPlay2Options::set_has_streamname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RtmpPlay2Options::clear_has_streamname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RtmpPlay2Options::clear_streamname() {
  if (streamname_ != &::google::protobuf::internal::kEmptyString) {
    streamname_->clear();
  }
  clear_has_streamname();
}
inline const ::std::string& RtmpPlay2Options::streamname() const {
  return *streamname_;
}
inline void RtmpPlay2Options::set_streamname(const ::std::string& value) {
  set_has_streamname();
  if (streamname_ == &::google::protobuf::internal::kEmptyString) {
    streamname_ = new ::std::string;
  }
  streamname_->assign(value);
}
inline void RtmpPlay2Options::set_streamname(const char* value) {
  set_has_streamname();
  if (streamname_ == &::google::protobuf::internal::kEmptyString) {
    streamname_ = new ::std::string;
  }
  streamname_->assign(value);
}
inline void RtmpPlay2Options::set_streamname(const char* value, size_t size) {
  set_has_streamname();
  if (streamname_ == &::google::protobuf::internal::kEmptyString) {
    streamname_ = new ::std::string;
  }
  streamname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtmpPlay2Options::mutable_streamname() {
  set_has_streamname();
  if (streamname_ == &::google::protobuf::internal::kEmptyString) {
    streamname_ = new ::std::string;
  }
  return streamname_;
}
inline ::std::string* RtmpPlay2Options::release_streamname() {
  clear_has_streamname();
  if (streamname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = streamname_;
    streamname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RtmpPlay2Options::set_allocated_streamname(::std::string* streamname) {
  if (streamname_ != &::google::protobuf::internal::kEmptyString) {
    delete streamname_;
  }
  if (streamname) {
    set_has_streamname();
    streamname_ = streamname;
  } else {
    clear_has_streamname();
    streamname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string transition = 6;
inline bool RtmpPlay2Options::has_transition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RtmpPlay2Options::set_has_transition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RtmpPlay2Options::clear_has_transition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RtmpPlay2Options::clear_transition() {
  if (transition_ != &::google::protobuf::internal::kEmptyString) {
    transition_->clear();
  }
  clear_has_transition();
}
inline const ::std::string& RtmpPlay2Options::transition() const {
  return *transition_;
}
inline void RtmpPlay2Options::set_transition(const ::std::string& value) {
  set_has_transition();
  if (transition_ == &::google::protobuf::internal::kEmptyString) {
    transition_ = new ::std::string;
  }
  transition_->assign(value);
}
inline void RtmpPlay2Options::set_transition(const char* value) {
  set_has_transition();
  if (transition_ == &::google::protobuf::internal::kEmptyString) {
    transition_ = new ::std::string;
  }
  transition_->assign(value);
}
inline void RtmpPlay2Options::set_transition(const char* value, size_t size) {
  set_has_transition();
  if (transition_ == &::google::protobuf::internal::kEmptyString) {
    transition_ = new ::std::string;
  }
  transition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtmpPlay2Options::mutable_transition() {
  set_has_transition();
  if (transition_ == &::google::protobuf::internal::kEmptyString) {
    transition_ = new ::std::string;
  }
  return transition_;
}
inline ::std::string* RtmpPlay2Options::release_transition() {
  clear_has_transition();
  if (transition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transition_;
    transition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RtmpPlay2Options::set_allocated_transition(::std::string* transition) {
  if (transition_ != &::google::protobuf::internal::kEmptyString) {
    delete transition_;
  }
  if (transition) {
    set_has_transition();
    transition_ = transition;
  } else {
    clear_has_transition();
    transition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RtmpInfo

// optional string code = 1;
inline bool RtmpInfo::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtmpInfo::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtmpInfo::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtmpInfo::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& RtmpInfo::code() const {
  return *code_;
}
inline void RtmpInfo::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void RtmpInfo::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void RtmpInfo::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtmpInfo::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* RtmpInfo::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RtmpInfo::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string level = 2;
inline bool RtmpInfo::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtmpInfo::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtmpInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtmpInfo::clear_level() {
  if (level_ != &::google::protobuf::internal::kEmptyString) {
    level_->clear();
  }
  clear_has_level();
}
inline const ::std::string& RtmpInfo::level() const {
  return *level_;
}
inline void RtmpInfo::set_level(const ::std::string& value) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  level_->assign(value);
}
inline void RtmpInfo::set_level(const char* value) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  level_->assign(value);
}
inline void RtmpInfo::set_level(const char* value, size_t size) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  level_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtmpInfo::mutable_level() {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  return level_;
}
inline ::std::string* RtmpInfo::release_level() {
  clear_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = level_;
    level_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RtmpInfo::set_allocated_level(::std::string* level) {
  if (level_ != &::google::protobuf::internal::kEmptyString) {
    delete level_;
  }
  if (level) {
    set_has_level();
    level_ = level;
  } else {
    clear_has_level();
    level_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 3;
inline bool RtmpInfo::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtmpInfo::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtmpInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtmpInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& RtmpInfo::description() const {
  return *description_;
}
inline void RtmpInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void RtmpInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void RtmpInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtmpInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* RtmpInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RtmpInfo::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double objectEncoding = 4;
inline bool RtmpInfo::has_objectencoding() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtmpInfo::set_has_objectencoding() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtmpInfo::clear_has_objectencoding() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtmpInfo::clear_objectencoding() {
  objectencoding_ = 0;
  clear_has_objectencoding();
}
inline double RtmpInfo::objectencoding() const {
  return objectencoding_;
}
inline void RtmpInfo::set_objectencoding(double value) {
  set_has_objectencoding();
  objectencoding_ = value;
}

// -------------------------------------------------------------------

// RtmpEmptyObject


// @@protoc_insertion_point(namespace_scope)

}  // namespace brpc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_brpc_2frtmp_2eproto__INCLUDED
